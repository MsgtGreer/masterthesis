% !TEX root = mythesis.tex

%==============================================================================
\chapter{MSP430 Firmware Update}
\label{sec:Software}
%==============================================================================
The software running on the MSP430 is written in C++ and then compiled using a special compiler provided with the microcontroller. Formerly the msp430-gcc compiler was used. To flash the new firmware a laptop running Ubuntu 10.01, equipped with the compiler and all related software was in use.
To simplify the flashing procedure and to enable flashing on modern systems the old software should be rewritten to be compatible with the new standards provided by TI.
TI released a new compiler for the msp microcontrollers, the addcompilername, and to simplify the developement an integrated developement environment (IDE), called Code Composer Studio (CCS) is provided. This IDE combines the programming, compilling and flashing tasks as well as all related settings.

\section{controll setup}\footnote{For details please refer to \cite{msp_manual}}
The programming of the msp microcontrollers is done via controll registers, with there bits corresponding to different options. to simplify acces to these registers and thei bits, the register adresses were given names via cpp \#define macros. All these definitions can be found in the header files, mainly the msp430f169.h. And for each bit then has a name according to its function. To manipulate the bits three main operations exist:
\begin{align}
%\&= ~ \leftrightarrow \text{, \		set bit  to 0}\notag\\
%|= \leftrightarrow \text{, \	set bit  to 1}\notag\\
%\mathaccent= \leftrightarrow \text{, \	change bit state} \notag
\end{align} 
For further simplification there are some defines for these operations contained in iostructures.h


\section{Digital IO pins}
Digital IO pins for the msp430 are grouped in ports with 8 pins numbered 0-7. All ports have the following controll registers:
\begin{description}
\item [in] contains the state externally applied to the pin, used for reading information
\item [out] used to set the pin level
\item [dir] determines whether a pin is used as in or output
\item [sel] select functionality
\end{description}
The pins 1 and 2 have some additional registers corresponding to their interrupt capability:
\begin{description}
	\item [ifg] the interrupt flag
	\item [ies] selects edge to trigger interrupt
	\item [ie] interupt enable/disable
\end{description}

Formerly each port was defined as a structure, the different registers were attributes to to the port and all pins were attributes to the registers. The new compiler does not support this definition. The Ports are now defined as 8 Bit registers alike the controll registers, with each pin corresponding to one bit [0-7], all changes to pin status are done by bit operations.  In comparism for a port Px setting the pin px in the output register:
\begin{minipage}[t]{0.49\textwidth}
	\begin{lstlisting}[style=cpp,language=C++]
Px.out.px=1;
	\end{lstlisting}
\end{minipage}	
\begin{minipage}[t]{0.49\textwidth}
	\begin{lstlisting}[style=cpp,language=C++]
PxOUT |= px;
	\end{lstlisting}
\end{minipage}
In the adc\_board.h file there are some defines for the ports to name them according to their purpose.
